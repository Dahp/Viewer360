import cv2
import numpy as np

def xyz2lonlat(xyz):
    atan2 = np.arctan2
    asin = np.arcsin

    norm = np.linalg.norm(xyz, axis=-1, keepdims=True)
    xyz_norm = xyz / norm
    x = xyz_norm[..., 0:1]
    y = xyz_norm[..., 1:2]
    z = xyz_norm[..., 2:]

    lon = atan2(x, z)
    lat = asin(y)
    lst = [lon, lat]

    out = np.concatenate(lst, axis=-1)
    return out

def lonlat2XY(lonlat, shape):
    X = (lonlat[..., 0:1] / (2 * np.pi) + 0.5) * (shape[1] - 1)
    Y = (lonlat[..., 1:] / (np.pi) + 0.5) * (shape[0] - 1)
    lst = [X, Y]
    out = np.concatenate(lst, axis=-1)

    return out 

class Equirectangular:
    #конструктор класса
        # self -- ссылка на текущий экземпляр класса.
        # img_name -- имя изображения
    def __init__(self, img_name):
        # self._img -- переменная экземпляра класса, в который будет храниться изображение
        self._img = img_name # присваивание имени изображения
        
        # тут мы извлекаем из self._img размеры изображения
        # при помощи метода shape
        # # shape возвращает кортеж из 3х элементов (высота, ширина, числа каналов изображения)
        [self._height, self._width, _] = self._img.shape
        # [высота, ширина, игнорируем число каналов]
    

    # Функция принимает следующие параметры:
        # self -- ссылка на текущий экземпляр класса, через который можно получить доступ к атрибутам и методам класса
        # FOV -- угол обзора в градусах. Определяет какая часть сцены будет видна в итоговом перспективном изображении.
        # THETA -- угол поворота вокруг вертикальной оси. Определяет наклон обзора сцены.
        # PHI -- угол поворота вокруг горизонтальной оси.
        # height -- высота (в пикселях) итогового перспективного изображения.
        # width -- ширина (в пикселях) итогового перспективного изображения
    def GetPerspective(self, FOV, THETA, PHI, height, width):
        # -- THETA определяет угол поворота вокруг вертикальной оси. Когда значение увеличивается, обзор сцены поворачивается влево или вправо.
        # Нулевое значение соотвествует прямому направлению обзора. 
        
        # -- PHI определяет угол поворота вокруг горизонтальной оси. Когда значение увеличивается, обзор сцены наплоняется вверх и вниз.
        # Нулевое значение соотвествует горизонтальному обзору.


        # # # Тут происходит вычисление параметров для матрицы проекции 'K', которая ипользуется для преобразования трехмерных
        # # # координат в двемерные координаты на плоскости изображения.
        f = 0.5 * width * 1 / np.tan(0.5 * FOV / 180.0 * np.pi) # в этой строке вычисляется расстояние 'f'. Фокусное расстояние определяет, насколько
        # далеко должна быть камера от плоскости изображения для правильного проецирования сцены.
        # значение FOV используется для определения вертикального угла обзора.
        # " 0.5 * FOV / 180.0 * np.pi " преобразует FOV из градусов в радианы, а затем вычисляется тангенс половины угла обзора.
        # Затем 'f' вычисляется как половина ширины изображения (width) умноженная на обратное значение тангенса половины угла обзора.
        # Это позволяет настроить размер объектов на плоскости изображения.
        
        cx = (width - 1) / 2.0 # в этой строке вычисляется центральная координата 'cx' по горизонтали. Значение 'cx' представляет середину 
        # плоскости изображения по горизонтали и используется для определения смещения объектов вдоль горизонтальной оси.
        cy = (height - 1) / 2.0 # В этой строке вычисляется центральная координата cy по вертикали. Значение cy представляет середину 
        # плоскости изображения по вертикали и используется для определения смещения объектов вдоль вертикальной оси.
        
        # # #Форма матрицы K определяется стандартами компьютерного зрения и графики, чтобы обеспечить правильное преобразование и масштабирование трехмерных координат на плоскость изображения.
        # Матрица проекции 'K' используется для преобразования трехмерных координат в двумерные координаты на плоскости изображния.
        K = np.array([
        # Первый столбец [f, 0, cx] отвечает за масштабирование и смещение по горизонтальной оси.
                [f, 0, cx],
        # Первый столбец [0, f, cy] отвечает за масштабирование и смещение по вертикальной оси.
                [0, f, cy],
        # И третий столбец является константой и не влияет на преобразование координат.
                [0, 0,  1],
            ], np.float32)
        K_inv = np.linalg.inv(K) # Инверсия матрицы K (K_inv) используется позже в коде для обратного преобразования из двумерных координат на плоскости изображения в трехмерные координаты.
        
        x = np.arange(width) # Создается одномерный массив x с числами от 0 до width-1. Этот массив представляет значения координаты x для каждого пикселя по горизонтали на плоскости изображения.
        y = np.arange(height) # Создается одномерный массив y с числами от 0 до height-1. Этот массив представляет значения координаты y для каждого пикселя по вертикали на плоскости изображения.
        x, y = np.meshgrid(x, y)
        z = np.ones_like(x)
        xyz = np.concatenate([x[..., None], y[..., None], z[..., None]], axis=-1)
        xyz = xyz @ K_inv.T

        y_axis = np.array([0.0, 1.0, 0.0], np.float32)
        x_axis = np.array([1.0, 0.0, 0.0], np.float32)
        R1, _ = cv2.Rodrigues(y_axis * np.radians(THETA))
        R2, _ = cv2.Rodrigues(np.dot(R1, x_axis) * np.radians(PHI))
        R = R2 @ R1
        xyz = xyz @ R.T
        lonlat = xyz2lonlat(xyz) 
        XY = lonlat2XY(lonlat, shape=self._img.shape).astype(np.float32)
        persp = cv2.remap(self._img, XY[..., 0], XY[..., 1], cv2.INTER_CUBIC, borderMode=cv2.BORDER_WRAP)

        return persp
    
